Delete all nodes in a linked list, so that there are no memory leaks. Write two methods, one recursive and one iterative.

---

Write a method that returns the height of a binary tree recursively. (Height is the number of hops between the root node and the lowest point of the binary tree). The binary tree is not balanced.

     o
    / \
   o   o        => height 3
  /
 o

---

Validate a binary search tree. A binary search tree is a binary tree such that all nodes in the left sub tree are less than the current node; and all nodes in the right subtree are greater than the current node.

    6
   / \
  3   7
       \    
        6       => Not valid
      /   \
     3     7
      \     \ 
       10    11

---

Given a 2D array filled with 1s and 0s (1s represent land, and 0s represent water). Count how many islands there are.

0 1 1 0
1 0 0 1
1 0 0 1    => 3 islands
1 0 1 1

---

You have a hallway filled with circular motion sensors, each centered at a point with a given radius. Find if there is a safe path through the hallway.

Example:

-----------------------------------------------------
   -----
 /       \
|    o    |
 \       /--------
   ----//          \
       |      o     |
-----------------------------------------------------

You are given a list of ‘Censor’ objects (each with an x,y point and radius), the height of the hallway, and the radius of the person.

---

Find if there are three values in an array of ints that add to a given key. (Fill the body of the given function header)

public static boolean threeSum(int[] array, int key) {  ..

---

Write a function to calculate the division (with decimal) of two values using ONLY integers. if there is a repeating decimal return a string with the repeating portion in brackets. (Fill out the body of the following function header)

public static String division(int a, int b) {  ..

---

Given an array of Iterators, return an array containing all values (maintaining order). For example:

array = [Iterator(1,4,2,5), Iterator(3,2), Iterator(5,6,4,7,5)]
will return
array = [1,3,5,4,2,6,2,4,5,7,5]

* Remember that iterators only have next() and hasNext(), no size method.

--



SOLUTIONS:


int binaryTreeHeight(TreeNode n) {

  int largerHeight;
  int leftHeight = 0;
  int rightHeight = 0;

  if (n == null)  {
    return 0;
  }

  leftHeight = height(n.left());
  rightHeight = height(n.right());

  if(leftHeight > rightHeight) {
    largerHeight = leftHeight;
  } else {
    largerHeight = rightHeight;
  }

  return largerHeight + 1;  
}


(boolean, int, int) validBST(TreeNode n) {
  boolean validity;
//want to find the highest value on the left
//want to find the lowest value on the right
//bool, high, low

  //base case
  if (n == null) {
    return true, MININT, MAXINT;
  }

  lValidity, lHigh, lLow = validBST(n.left());
  rValidity, rHigh, rLow = validBST(n.right());

  validity = ((n.value >= lHigh) && (n.value <= rLow) 
    && lValidity && rValidity);

  return validity, rHigh, lLow;
}


void deleteLinkedList(Node head) {
  Node deleteNode = head;

  while(head != null) {
    Node cur = head;
    while(cur.next() != null) {
      deleteNode = cur.next();
    }
    delete(deleteNode);
  }
}


void deleteLinkedList(Node head) {
  if (head == null) {
    return;
  }

  deleteLinkedList(head.next());
  delete(head);
}

